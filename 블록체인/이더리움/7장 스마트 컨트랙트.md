# 7장 스마트 컨트랙트

## 스마트 컨트랙트란?

- 컴퓨터 프로그램
- 불변의
    - 일단 배포되면 변경 불가.
- 결정론적
    - 실행을 시작한 트랜잭션의 컨텍스트와 실행 지점에 이더리움 블록체인의 상태가 동일하다는 전제가 있기에, 스마트 컨트랙트를 실행한 결과물은 모든 이에게 동일함
- EVM 컨텍스트
    - 제한적 실행 컨텍스트에서 작동
- 탈중앙화된 월드 컴퓨터
    - EVM은 노드에서 실행되지만, EVM의 모든 인스턴스는 동일한 초기상태에서 작동하고 동일한 최종 상태를 생성하기 때문에 시스템 전체가 단일 월드 컴퓨터로 작동한다.

---

## 스마트 컨트랙트의 생명주기

스마트 컨트랙트는 **Solidity**로 작성됨 → EVM은 바이트코드로 컴파일 되어야함

컨트랙트 작성은 to 필드에 ‘0x0’ 주소를 포함 (p. 124 특별 트랜잭션: 컨트랙트 생성)

컨트랙트가 트랜잭션에 의해 호출된 경우에만 실행됨

모든 스마트 컨트랙트는 EOA에서 시작된 트랜잭션에 의해 실행됨

컨트랙트가 컨트랙트를 호출하는 등의 체인형태를 갖고 있을 수 있으나 가장 처음에 실행되는 컨트랙트는  결국 EOA로부터 트랜잭션에 의해 호출됨

컨트랙트 코드는 변경 불가.

But 컨트랙트 삭제로 해당 주소를 빈 상태로 남길 수 있음

컨트랙트 삭제 : EVM에서 SELFDESTRUCT 연산코드를 실행

→ 이 작업은 “음의 가스”, 가스 환불이 일어나는 작업

컨트랙트 트랜잭션 내용이 제거되지는 않음

---

## 이더리움 고급 언어의 소개

EVM : 컴퓨터의 CPU와 유사한 EVM 바이트코드를 실행하는 가상 머신

스마트 컨트랙트를 바이트코드로 직접 코딩하는 것도 가능, But 프로그래머가 읽고 이해하기 매우 어려움

### 프로그래밍 언어?

**명령형 프로그래밍 (imperative)**

- 논리와 흐름을 결합하는 일련의 절차를 작성
- 선언형 패러다임 작성 가능, 하지만 어색할 수 있음
- ‘예상대로 정확하게’ 실행되는 프로그램 작성 어려움
- C++, JAVA

**선연형 프로그래밍 (declarative)**

- 프로그램의 논리를 표현 o, 흐름은 표현 x **부작용이 없는 프로그래밍에 용이**
    
    → 함수 외부의 상태 변경 x
    
- 명령형 패러다임 작성 불가능
- 프로그램이 어떻게 작동하는지 쉽게 이해 가능
- 하스켈(Haskell), SQL

스마트 컨트랙트에서의 버그는 비용과 직결됨

따라서 선언형 프로그래밍이 유리함

**But** 프로그래머는 변화를 쉽게 받아들이지 않기에 명령형 프로그래밍 언어인 솔리디티 애용

### 스마트 컨트랙트에 쓰이는 고급 언어

- LLL(Low-level Lisp-like Language)
- Serpent
- **Solidity**
- Vyper
- Bamboo

---

## 솔리디티로 스마트 컨트랙트 생성

개빈 우드, 스마트 컨트랙트 작성을 위해 만들어진 언어

### 현재 버전과 책 내용 차이점

- 라이센스(주석 처리)와 solidity 버전 명을 적어줘야됨
- msg.sender는 address 타입인데, 전송의 경우 payable을 붙여줘야 함
- 마지막 컨트랙트에서 함수가 있으면 fallback, 없으면 receive를 적어준다.

```jsx
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.7;
// 라이센스와 버전을 입력해야함
// 라이센스는 주석으로 처리, 버전은 ^, >= 0.8과 같이 범위로 지정해줘도 됨

contract Faucet{
    // 요청하는 사람에게 이더 주기
    function withdraw(uint withdraw_amount) public {

        // 출금 금액 제한
        require(withdraw_amount <= 100000000000000000);

        // 요청한 주소로 금액 보내기
            payable(msg.sender).transfer(withdraw_amount);
            // msg.sender 는 address, 전송하려면 payable이 붙어야됨
        
    }

    // 입금 금액 수락
    receive () external payable{}
    // function이 있을 경우 receive 대신 fallback
}
```

## 솔리디티로 프로그래밍 하기

### 데이터 타입

- bool
- 정수(int, uint)
    - int : 부호 있는 정수
    - uint : 부호 없는 정수
- 고정소수점(fixed, ufixed) : (u)fixed*MxN, M은 비트단위 크기, N은 소수점 이하 자릿수*
- 주소 : 20바이트 이더리움 주소
- 바이트 배열(고정 크기) : bytes1 ~ bytes32
- 바이트 배열(가변 크기) : bytes || string 가변 크기 배열
- 열거형 : 이산값 열거
- 배열
- 구조체 : 변수 그룹화를 위한 데이터 컨테이너
- 매핑

### 사전 정의된 글로벌 변수 및 함수

**트랜잭션 / 메시지 콜 컨텍스트**

msg 객체 : 컨트랙트를 실행을 시작한 트랜잭션 호출 또는 메시지 호출

- msg.sender : 컨트랙트 호출을 시작한 주소 → 서명한 주소 || 컨트랙트 주소
- msg.value : 호출과 함께 전송된 이더 값
- msg.gas : 가스 공급에 남은 가스의 양
- msg.data
- msg.sig : 데이터 페이로드의 처음 4바이트

**트랜잭션 컨텍스트**

tx 객체 : 트랜잭션 정보 접근

- tx.gasprice : 트랜잭션 호출 필요 가스
- tx.origin : 트랜잭션 원래 EOA 주소 (안전하지 않음)

**블록 컨텍스트**

block 객체 : 현재 블록 정보

- block.blockhash(blockNumber)
- block.coinbase
- block.difficulty
- block.gaslimit
- block.number
- block.timestamp

**address 객체**

- address.balance : 주소의 잔액, 웨이로 표시
- address.transfer(amount) : 주소로 전송, 오류 발생 시 예외처리
- address.send(amount) : 주소로 전송, 오류 발생 시 false 반환
- address.call(payload) :
- address.callcode(payload)
- address.delegatecall()

**내장 함수**

- addmod, mulmod : addmod(x, y, k) === (x + y) % k
- keccak256, sha256, sha3, ripemd160
- ecrecover : 서명 중 메시지 서명에 사용된 주소 복구
- selfdestrunct(recipient_address) : 현재 컨트랙트 삭제, 계정의 나머지 이더 전송
- this : 현재 실행 컨트랙트 계정 주소

### 컨트랙트 정의

contract 객체 : 솔리디티 주요 데이터 타입

- interface
- library

### 함수

컨트랙트 내에서 EOA 트랜잭션, 다른 컨트랙트에 의해 호출 될 수 있는 함수

```jsx
function FunctionName([parameters]) {public | private | internal | external }
[pure | constant | view | payable] [modifiers] [returns (return types)]
```

- FunctionName

- parameters
- public
- external : 공개함수와 같으나 컨트랙트 내에서 호출 할 수 없음
- internal : 컨트랙트 내에서만 접근 가능
- private : 내부 함수와 유사하나, 파생된 컨트랙트에서도 호출 불가

- constant || view :
- pure : 변수를 읽거나 쓰지 않는 함수, 저장된 데이터 사용 x, 인수에 대해서만 작동 및 반환
- payable : 입금을 받을 수 있는 함수, 없으면 입금 거부됨

### 컨트랙트 생성자 및 selfdestruct

컨트랙트 생성 시, 생성자 함수가 있으면 실행해서 컨트랙트 상태를 초기화함

생성자를 지정하는 방법

- 컨트랙트와 동일한 이름의 함수
    - 만약에 오타가 하나라도 나면 작동하지 않음
    - 컨트랙트의 이름 변경 시, 이러한 오류가 일어날 확률이 큼
- constructor
    - 0.4.22 버전부터 생성자 함수처럼 작동하는 이름 없는 키워드 도입
    - 키워드 도입으로 어떤 함수가 생성자 함수인지에 대한 가독성 증가
    

컨트랙트 생명주기는 EOA || 컨트랙트 계정의 트랜잭션 생성으로 시작함

생성자가 있는 경우, 컨트랙트 생성 시 상태를 초기화하고 소멸함

생명주기의 끝은 컨트랙트 소멸, SELFDESTRUCT 라는 EVM 연산 코드에 의해 소멸됨.

솔리디티에서는 selfdestruct 내장 함수로 표시

인수 컨트랙트 계정에 남아있는 이더 잔액을 받기 위한 주소

```jsx
selfdestruct(address recipient); // 삭제 가능 컨트랙트 생성 시 명시
```
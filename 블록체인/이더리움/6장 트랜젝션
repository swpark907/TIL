# 6장 트랜젝션

## 트랜젝션의 구조

시리얼라이즈된 트랜잭션을 수신하는 각 클라이언트와 어플리케이션은 자체 내부 데이터 구조를 사용하여 트랜잭션을 메모리에 저장. → 네트워크에서 시리얼라이즈 된 트랜잭션 자체에는 존재하지 않는 메타데이터가 포함되어 있음.

네트워크 시리얼라이제이션은 트랜잭션의 유일한 표준형식임.

트랜젝션은 다음 데이터를 포함하는 시리얼라이즈된 바이너리 메시지임.

- **논스(nonce)**
    - 발신 EOA(외부 소유 어카운트)에 의해 발행되어 메시지 재사용을 방지하는데 사용되는 일련번호
- **가스 가격(gas price)**
    - 발신자가 지급하는 가스의 가격(웨이)
- **가스 한도(gas limit)**
    - 이 트랜잭션을 위해 구입할 가스의 최대량
- **수신자**
    - 목적지 이더리움 주소
- **값(value)**
    - 목적지에 보낼 이더의 양
- **데이터**
    - 가변 길이 바이너리 데이터 페이로드
- **v, r, s**
    - EOA의 ECDAS 디지털 서명의 세가지 구성요소

RLP(Recursive Length Prefix) 인코딩 체계를 사용해 시리얼라이즈 됨.

→ 이더리움의 모든 숫자는 8비트 배수 길이의 빅엔디안 정수로 인코딩됨

내부 정보, 사용자 인터페이스 시각화를 위해 트랜잭션이나 블록체인에서 파생된 추가정보를 사용

## 트랜잭션 논스

황서에 의하면 논스란

- 해당 주소에서 보낸 트랜잭션 건수 또는 연결된 코드가 있는 계정의 경우 이 계정에서 만든 컨트랙트 생성 건수와 동일한 스칼라 값
- 계정에 저장된 값이 아닌, 해당 주소에서 발생한 트랜잭션 건수를 동적으로 확인, 계산된 값

### 논스의 사용처

- **순서를 정하는데 사용**
    - 여러가지 트랜잭션이 발생할 때, 논스값을 달아서 먼저 처리할 트랜잭션을 설정할 수 있음.
- **트랜잭션 복제 방지에 사용**
    - 누군가가 트랜젝션을 복제하여 악용하려는 경우, 논스값이 각 트랜잭션의 고유성을 증명해 복제하는 행위를 막을 수 있음.

위와 같은 이유로 UTXO가 아닌, 계정 기반 프로토콜은 논스 사용이 필수적임.

## 논스 추적

## 논스의 간격, 중복 논스 및 확인

### 간격확인

1. 논스가 2인 트랜잭션을 전송하면
2. 노드들은 논스가 1인 트랜잭션이 누락되었다고 가정하고 멤풀에 저장.
3. 그후 논스가 1인 트랜잭션을 전송하면,
4. 1을 처리한 후, 2을 이어서 처리한다.

### 중복확인

1. 논스가 같은 트랜잭션이 동시에 들어오면
2. 유효노드에 먼저 도달하는 것이 확정되고, 나머지는 거부됨.

이렇게 논스값을 추적해야 할 필요가 있음.

## 동시 실행, 트랜잭션 생성 및 논스

### 단일 컴퓨터

1. 단일컴퓨터를 사용하면 선착순으로 논스를 할당 할 수 있다.
2. 하지만 이 컴퓨터가 단일 실패 지점이 된다.
3. 논스가 중간에 사용되지 않으면, 이후의 트랜잭션은 모두 중단된다.

### 논스를 생성하지 않는 방법

1. 논스를 할당하지 않고, 노드 대기열에 올려서 노드가 논스를 관리하는 방법
2. 노드가 과부하 될 수 있음.
3. 여전히 동시 실행 문제는 남아있음.

### 결국..

동시실행을 최대한 피하고 단일 프로세스를 만드는 것처럼

병목지점을 받아들이거나, 독립적으로 작동하는 다수의 출금담당 핫 월렛을 설치하고

중간중간에 밸런스를 채워주는 형식으로 해결해야 함.

## 트랜잭션 가스

가스: 이더리움의 연료, 별도의 가상화폐 →
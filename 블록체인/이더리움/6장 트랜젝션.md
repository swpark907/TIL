# 6장 트랜젝션

## 트랜젝션의 구조

시리얼라이즈된 트랜잭션을 수신하는 각 클라이언트와 어플리케이션은 자체 내부 데이터 구조를 사용하여 트랜잭션을 메모리에 저장. → 네트워크에서 시리얼라이즈 된 트랜잭션 자체에는 존재하지 않는 메타데이터가 포함되어 있음.

네트워크 시리얼라이제이션은 트랜잭션의 유일한 표준형식임.

트랜젝션은 다음 데이터를 포함하는 시리얼라이즈된 바이너리 메시지임.

- **논스(nonce)**
    - 발신 EOA(외부 소유 어카운트)에 의해 발행되어 메시지 재사용을 방지하는데 사용되는 일련번호
- **가스 가격(gas price)**
    - 발신자가 지급하는 가스의 가격(웨이)
- **가스 한도(gas limit)**
    - 이 트랜잭션을 위해 구입할 가스의 최대량
- **수신자**
    - 목적지 이더리움 주소
- **값(value)**
    - 목적지에 보낼 이더의 양
- **데이터**
    - 가변 길이 바이너리 데이터 페이로드
- **v, r, s**
    - EOA의 ECDAS 디지털 서명의 세가지 구성요소

RLP(Recursive Length Prefix) 인코딩 체계를 사용해 시리얼라이즈 됨.

→ 이더리움의 모든 숫자는 8비트 배수 길이의 빅엔디안 정수로 인코딩됨

내부 정보, 사용자 인터페이스 시각화를 위해 트랜잭션이나 블록체인에서 파생된 추가정보를 사용

## 트랜잭션 논스

황서에 의하면 논스란

- 해당 주소에서 보낸 트랜잭션 건수 또는 연결된 코드가 있는 계정의 경우 이 계정에서 만든 컨트랙트 생성 건수와 동일한 스칼라 값
- 계정에 저장된 값이 아닌, 해당 주소에서 발생한 트랜잭션 건수를 동적으로 확인, 계산된 값

### 논스의 사용처

- **순서를 정하는데 사용**
    - 여러가지 트랜잭션이 발생할 때, 논스값을 달아서 먼저 처리할 트랜잭션을 설정할 수 있음.
- **트랜잭션 복제 방지에 사용**
    - 누군가가 트랜젝션을 복제하여 악용하려는 경우, 논스값이 각 트랜잭션의 고유성을 증명해 복제하는 행위를 막을 수 있음.

위와 같은 이유로 UTXO가 아닌, 계정 기반 프로토콜은 논스 사용이 필수적임.

## 논스 추적

## 논스의 간격, 중복 논스 및 확인

### 간격확인

1. 논스가 2인 트랜잭션을 전송하면
2. 노드들은 논스가 1인 트랜잭션이 누락되었다고 가정하고 멤풀에 저장.
3. 그후 논스가 1인 트랜잭션을 전송하면,
4. 1을 처리한 후, 2을 이어서 처리한다.

### 중복확인

1. 논스가 같은 트랜잭션이 동시에 들어오면
2. 유효노드에 먼저 도달하는 것이 확정되고, 나머지는 거부됨.

이렇게 논스값을 추적해야 할 필요가 있음.

## 동시 실행, 트랜잭션 생성 및 논스

### 단일 컴퓨터

1. 단일컴퓨터를 사용하면 선착순으로 논스를 할당 할 수 있다.
2. 하지만 이 컴퓨터가 단일 실패 지점이 된다.
3. 논스가 중간에 사용되지 않으면, 이후의 트랜잭션은 모두 중단된다.

### 논스를 생성하지 않는 방법

1. 논스를 할당하지 않고, 노드 대기열에 올려서 노드가 논스를 관리하는 방법
2. 노드가 과부하 될 수 있음.
3. 여전히 동시 실행 문제는 남아있음.

### 결국..

동시실행을 최대한 피하고 단일 프로세스를 만드는 것처럼

병목지점을 받아들이거나, 독립적으로 작동하는 다수의 출금담당 핫 월렛을 설치하고

중간중간에 밸런스를 채워주는 형식으로 해결해야 함.

## 트랜잭션 가스

가스: 이더리움의 연료, 별도의 가상화폐 

gasPrice : 가스 가격

gasLimit : 트랜젝션 완료를 위해 기꺼이 지불할 수 있는 가스 단위 수, 21000

## 트랜잭션 수신자

to필드 : EOA 또는 컨트랙트 주소에 20바이트의 이더리움 주소 포함

## 트랜잭션 값과 데이터

페이로드 안에는 두가지가 있음. 값, 데이터

값이 있는 경우: 지급

데이터가 있는 경우: 호출

### EOA, 컨트랙트에 값 전달

**EOA에 전달하는 경우**

- 상태변경을 기록하여 주소 잔액에 보낸 값을 추가
- 주소가 표시되지 않은 경우는 지급금액으로 초기화

**컨트랙트에 전달하는 경우**

- 컨트랙트를 실행하고 함수를 실행하려고 시도
- 트랜잭션에 데이터가 없으면 폴백함수 호출, 해당 함수가 지급 가능하다면 함수 실행
- 폴백함수가 없다면 컨트랙트의 잔액을 늘림

**특별 트랜잭션 : 컨트랙트 생성**

## 디지털 서명

### 타원 곡선 디지털 서명 알고리즘

디지털 서명의 용도 3가지

- 컨트랙트 이행 **승인 증명**
- **부인 방지**
- **수정할 수 없음을 증명**

### 디지털 서명 작동 방법

- 메시지에서 개인키를 사용하여 서명을 만드는 알고리즘
- 누구나 메시지와 공개키만 사용하여 서명을 검증할 수 있는 알고리즘

공식 삽입 요망

### 서명 확인

서명을 확인하기 위해서는

- 서명(r 및 s)
- 시리얼라이즈된 트랜잭션
- 개인키에 상응하는 공개키

**공개키를 생성한 개인키의 소유자만이 트랜잭션에서 서명을 생성할 수 잇음을 의미함**

메시지(트랜잭션 해시), 서명자의 공개키 및 서명(r 및 s)를 가져와서

→ 서명이 메시지와 공개키에 유효하면 true반환 → 검증

### ECDSA 계산

서명 == r 과 s로 구성된 서명을 생성하는 수학 함수 Fsig  에 의해 생성됨

처음에는 ㅇㅁ시 개인키를 암호학적인 안전한 방법으로 생성

이 임시 키는 이더리움 네트워크에서 서명된 트랜잭션을 보는 공격자가 발산자의 실제 개인키를 계산할 수 없도록 r 및 s 값을 계산하는 데 사용됨.

### 트랜잭션 서명 실습

유효한 트랜잭션을 생성하기 위해 사용자는 ECDSA 를 사용해 메시지에 디지털 서명을 해야함

서명은 트랜잭션 자체가 아니라 트랜잭션 데이터의 해시에 적용됨

**트랜잭션 발생 과정**

1. nonce, gasPrice, gasLimit, to, value, data, chainID, 0, 0 의 9개의 필드를 포함한 데이터 구조 생성
2. RLP로 인코딩된 트랜잭션 데이터 구조의 시리얼라이즈 메시지 생성
3. 해당 메시지 Keccac-256으로 해시
4. 원래 EOA 개인키로 해시에 서명, ECDSA 서명 계산
5. ECDSA 서명의 계산된 v, r, s값을 트랜잭션에 추가

**v의 의미**

- ECDSArecover 함수가 서명을 확인하는 데에 필요한 복구식별자
- 체인 ID

27, 28 중 하나로 계산 || 체인ID의 두배에 35 또는 36을 더함

### 원시 트랜잭션 생성 및 서명

읽어보기 p.132

### EIP-155를 사용한 원시 트랜잭션 생성

**EIP-155란?** 단순 재생 공격 방지 표준

서명하기 전에 트랜잭션 데이터 내부의 체인 식별자 포함, 재생 공격 방지 가능한 트랜잭션 인코딩을 지정

→ 하나의 블록체인 기반으로 생성된 다른 트랜잭션들 끼리 서로 유효하지 않음.

체인 식별자 ID는 다음 값을 따름

| 체인 |  체인 ID |
| --- | --- |
| 이더리움 메인 넷 | 1 |
| 모던, 확장 | 2 |
| 롭스텐 | 3 |
| 린케비 | 4 |
| 루트스톡 메인넷 | 30 |
| 루트스톡 테스트넷 | 31 |
| 코반 | 41 |
| 이더리움 클래식 메인넷 | 61 |
| 이더리움 클래식 테스트넷 | 62 |
| 게스 사설 테스트넷 | 1337 |

RLP로 인코딩, 해싱, 서명됨

서명 알고리즘은 v접두어에 체인 식별자를 인코딩하기 위해 약간 수정됨

## 서명 접두어 값(v) 및 공개키 복구

트랜잭션 메시지는 발신자 필드를 포함하지 않음

why? 발신자 공개키는 ECDSA 서명을 통해 직접 계산될 수 있기 때문 → 공개키로 주소 계산 가능

이를 **공개키 복구**라 한다

r, s로 2개의 공개키 계산 가능

## 서명 및 전송 분리(오프라인 서명)

트랜잭션이 서명되면 트랜잭션은 이더리움 네트워크로 전송할 준비

트랜잭션 생성, 서명 브로드캐스트는 단일 작업에 의해 처리됨

- 단일 작업? → web3.eth.sendTransaction 사용

서명된 트랜잭션은 16진수로 인코딩하고 서명 후 이더리움 네트워크로 전송

서명과 전송을 분리하려는 이유? → 보안

서명하는 컴퓨터에는 잠금 해제된 개인키가 메모리에 로드되어 있어야 함.

→ 해당 컴퓨터는 인터넷에 연결되어 클라이언트를 실행해야 함

이렇게 되면 온라인 시스템에 개인키가 있게 되고 이는 매우 위험.

따라서 서명 및 전송을 분리하여 수행 == 오프라인 서명

**오프라인 서명 프로세스**

1. 현재 논스 및 자금을 검색할 수 있는 계정에서 서명되지 않은 트랜잭션을 온라인 컴퓨터화 시킴
2. 서명 안된 트랜잭션을 QR or USB를 통해 서명을 위한 에어 갭 오프라인 장치로 전송
3. 브로드캐스트를 위해 QR or USB를 통해 온라인으로 전송